package invopop

import (
	"context"
	"errors"
	"io"
	"path"

	"github.com/invopop/gobl/uuid"
)

const (
	siloAttachmentsPath = "attachments"
)

// SiloAttachmentsService implements the Invopop Silo API.
type SiloAttachmentsService service

// SiloAttachment represents a file that was generated by one of the job's intents
// and is stored by the Silo service.
type SiloAttachment struct {
	// The UUID that identifies the attachment.
	ID string `json:"id" title:"ID"`
	// ISO date and time this attachment was created.
	CreatedAt string `json:"created_at" title:"Created At" example:"2018-01-01T00:00:00.000Z"`
	// Name of the file.
	Name string `json:"name" title:"Name" example:"invoice.pdf"`
	// Description of the file's contents.
	Desc string `json:"desc,omitempty" title:"Description" example:"Invoice for January 2021."`
	// SHA256 hash of the file's contents.
	Hash string `json:"hash" title:"Hash" example:"a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6"`
	// File content's MIME type.
	MIME string `json:"mime" title:"MIME" example:"application/pdf"`
	// Size in bytes of the file.
	Size int32 `json:"size" title:"Size" example:"12345"`
	// When true, indicates that the file's contents have been uploaded successfully.
	Stored bool `json:"stored" title:"Stored" example:"true"`
	// Public URL where the file can be downloaded.
	URL string `json:"url" title:"Public URL"` // public URL
	// Any additional meta data about the attachment.
	Meta map[string]string `json:"meta,omitempty" title:"Meta"`
}

// CreateSiloAttachment can be used to upload a new file to a silo entry.
type CreateSiloAttachment struct {
	// UUID of attachment to create
	ID string `json:"-" title:"ID"`
	// UUID of the associated silo entry
	EntryID string `json:"-" title:"Entry ID"`
	// Name of the file, e.g. invoice.xml
	Name string `json:"name" title:"Name"`
	// Optional description of the contents
	Desc string `json:"desc,omitempty" title:"Description"`
	// Raw file data
	Data []byte `json:"data" title:"Data"`
	// MIME data type, determined by server if not provided
	MIME string `json:"mime,omitempty" title:"MIME"`
	// When true, the embeddable flag implies that this document *may* be
	// included inside other attachments. Useful for example to embed XML
	// documents inside PDFs.
	Embeddable bool `json:"embeddable,omitempty" title:"Embeddable"`
	// Any additional meta data about the attachment.
	Meta map[string]string `json:"meta,omitempty" title:"Meta"`
}

// Create will upload the provided silo attachment data to the silo service
// and store with the silo entry. If the request does not have a UUID, one will be
// assigned automatically.
func (s *SiloAttachmentsService) Create(ctx context.Context, req *CreateSiloAttachment) (*SiloAttachment, error) {
	if req.ID == "" {
		req.ID = uuid.V7().String()
	}
	if req.EntryID == "" {
		return nil, errors.New("missing entry_id")
	}
	if len(req.Data) == 0 {
		return nil, errors.New("missing data")
	}
	if req.Name == "" {
		return nil, errors.New("missing name")
	}
	p := path.Join(siloBasePath, entriesPath, req.EntryID, siloAttachmentsPath, req.ID)
	m := new(SiloAttachment)
	return m, s.client.put(ctx, p, req, m)
}

// Download provides a reader to be able to fetch the attachment's raw contents.
func (s *SiloAttachmentsService) Download(ctx context.Context, entryID, id string) (io.ReadCloser, error) {
	if id == "" {
		return nil, errors.New("missing id")
	}
	if entryID == "" {
		return nil, errors.New("missing entry_id")
	}

	p := path.Join(siloBasePath, entriesPath, entryID, siloAttachmentsPath, id)
	re := new(ResponseError)
	res, err := s.client.conn.R().
		SetContext(ctx).
		SetDoNotParseResponse(true).
		SetError(re).
		Get(p)
	if err != nil {
		return nil, err
	}
	return res.RawBody(), re.handle(res)
}
