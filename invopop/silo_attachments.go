package invopop

import (
	"context"
	"errors"
	"io"
	"path"

	"github.com/invopop/gobl/uuid"
)

const (
	siloAttachmentsPath = "attachments"
)

// File category constants that match those defined in the Silo service.
// These values are used to categorize attachments and are validated by
// the Silo service when creating attachments.
const (
	// FileCategoryDefault is the blank/default category for backwards compatibility.
	// Ideally we'll want to move away from this moving forward.
	FileCategoryDefault = ""

	// FileCategoryFormat represents alternative representations of the GOBL document,
	// like PDF or XML files.
	FileCategoryFormat = "format"

	// FileCategoryRequest represents files that are generated as part of API calls
	// and are only useful for future reference. They should not be sent to other users.
	// For example, VERI*FACTU generated payloads, or other reporting information
	// sent to tax authorities.
	FileCategoryRequest = "request"

	// FileCategoryResponse represents files received during the life cycle of the document,
	// including confirmations from tax authorities and IRs received via Peppol.
	FileCategoryResponse = "response"

	// FileCategoryAgreement represents legal documents usually signed by third parties,
	// such as the VERI*FACTU delegation agreement or the Peppol contract.
	FileCategoryAgreement = "agreement"

	// FileCategoryVerification represents passports, ID cards, and other proof of
	// ownership documents used in KYC flows.
	FileCategoryVerification = "verification"

	// FileCategoryAttachment represents attachments extracted from the GOBL invoice
	// under the attachments section.
	FileCategoryAttachment = "attachment"
)

// SiloAttachmentsService implements the Invopop Silo API.
type SiloAttachmentsService service

// SiloAttachment represents a file that was generated by one of the job's intents
// and is stored by the Silo service.
type SiloAttachment struct {
	// The UUID that identifies the attachment.
	ID string `json:"id" title:"ID"`
	// ISO date and time this attachment was created.
	CreatedAt string `json:"created_at" title:"Created At" example:"2018-01-01T00:00:00.000Z"`
	// Name of the file.
	Name string `json:"name" title:"Name" example:"invoice.pdf"`
	// Description of the file's contents.
	Desc string `json:"desc,omitempty" title:"Description" example:"Invoice for January 2021."`
	// Key used to identify the attachment idempotently within a silo entry.
	Key string `json:"key,omitempty" title:"Key" example:"logo"`
	// Category of the attachment.
	Category string `json:"category,omitempty" title:"Category" example:"format"`
	// SHA256 hash of the file's contents.
	Hash string `json:"hash" title:"Hash" example:"a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6"`
	// File content's MIME type.
	MIME string `json:"mime" title:"MIME" example:"application/pdf"`
	// Size in bytes of the file.
	Size int32 `json:"size" title:"Size" example:"12345"`
	// When true, indicates that the file's contents have been uploaded successfully.
	Stored bool `json:"stored" title:"Stored" example:"true"`
	// Can this file be embedded inside other files?
	Embeddable bool `json:"embeddable,omitempty" title:"Embeddable"`
	// Should this file be accessible without authentication?
	Private bool `json:"private,omitempty" title:"Private"`
	// Public URL where the file can be downloaded.
	URL string `json:"url" title:"Public URL"` // public URL
	// Any additional meta data about the attachment.
	Meta map[string]string `json:"meta,omitempty" title:"Meta"`
	// Previous version of the attachment.
	Previous []*SiloAttachmentVersion `json:"previous,omitempty" title:"Previous"`
}

// SiloAttachmentVersion contains a single version of a previously uploaded
// attachment.
type SiloAttachmentVersion struct {
	// ID of the attachment version
	ID string `json:"id" title:"ID"`
	// When the attachment was created
	CreatedAt string `json:"created_at" title:"Created At"`
	// SHA256 of the file's data.
	Hash string `json:"hash" title:"Hash"`
	// Size of the payload.
	Size int32 `json:"size" title:"Size"`
}

// CreateSiloAttachment can be used to upload a new file to a silo entry.
type CreateSiloAttachment struct {
	// UUID of attachment to create
	ID string `json:"-" title:"ID"`
	// UUID of the associated silo entry
	EntryID string `json:"-" title:"Entry ID"`
	// Name of the file, e.g. invoice.xml
	Name string `json:"name" title:"Name"`
	// Optional description of the contents
	Desc string `json:"desc,omitempty" title:"Description"`
	// Key used to identify the attachment idempotently within a silo entry
	Key string `json:"key,omitempty" title:"Key"`
	// Category of the attachment
	Category string `json:"category,omitempty" title:"Category"`
	// Raw file data
	Data []byte `json:"data" title:"Data"`
	// MIME data type, determined by server if not provided
	MIME string `json:"mime,omitempty" title:"MIME"`
	// When true, the embeddable flag implies that this document *may* be
	// included inside other attachments. Useful for example to embed XML
	// documents inside PDFs.
	Embeddable bool `json:"embeddable,omitempty" title:"Embeddable"`
	// When true, do not generate publically accessible links to the attachment.
	Private bool `json:"private,omitempty" title:"Private"`
	// Any additional meta data about the attachment.
	Meta map[string]string `json:"meta,omitempty" title:"Meta"`
}

// Create will upload the provided silo attachment data to the silo service
// and store with the silo entry. If the request does not have a UUID, one will be
// assigned automatically.
func (s *SiloAttachmentsService) Create(ctx context.Context, req *CreateSiloAttachment) (*SiloAttachment, error) {
	if req.ID == "" {
		req.ID = uuid.V7().String()
	}
	if req.EntryID == "" {
		return nil, errors.New("missing entry_id")
	}
	if len(req.Data) == 0 {
		return nil, errors.New("missing data")
	}
	if req.Name == "" {
		return nil, errors.New("missing name")
	}
	p := path.Join(siloBasePath, entriesPath, req.EntryID, siloAttachmentsPath, req.ID)
	m := new(SiloAttachment)
	return m, s.client.put(ctx, p, req, m)
}

// Download provides a reader to be able to fetch the attachment's raw contents.
func (s *SiloAttachmentsService) Download(ctx context.Context, entryID, id string) (io.ReadCloser, error) {
	if id == "" {
		return nil, errors.New("missing id")
	}
	if entryID == "" {
		return nil, errors.New("missing entry_id")
	}

	p := path.Join(siloBasePath, entriesPath, entryID, siloAttachmentsPath, id)
	re := new(ResponseError)
	res, err := s.client.conn.R().
		SetContext(ctx).
		SetDoNotParseResponse(true).
		SetError(re).
		Get(p)
	if err != nil {
		return nil, err
	}
	return res.Body, re.handle(res)
}
